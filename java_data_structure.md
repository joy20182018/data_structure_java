cmd中java命令中文乱码
在系统变量中加JAVA_TOOL_OPTIONS     -Dfile.encoding=UTF-8

映射：Map，存储一种键值对关系的数据结构

普通队列：先进先出FIFO
优先队列：出队顺序和入队顺序无关 ，和优先级有关
动态选择优先级最高的任务先执行
用堆实现  入队： O(logn)  出队：O(logn)
二叉堆：堆中某个节点的值总是不大于其父节点的值，是最大堆 
parent(i) = i / 2
left child(i) = 2 * i
right child(i) = 2 * i + 1
如果是最大堆，则向其中添加节点的时候，要满足最大堆的大小的排序顺序
replace操作：取出堆的最大值，然后放入一个新的元素  ---> 直接将堆顶元素替换，然后最siftDown
heapify： 将任意数组整理成堆的形状  O(n)复杂度
完全二叉树一定是平衡二叉树

线段树：（区间树）每个节点除叶子节点外都是一个区间的统计值，叶子节点为单位区间
线段树不是完全二叉树，是平衡二叉树
区间查询：



 并查集：解决网络中节点间的连接问题         -----> 连接问题和路径问题
            数学中集合类的实现
二中实现方式，四种改进方式
数组实现和二叉树实现
改进1：根据两个元素所在树的元素个数不同判断合并方向。先设置一个数组，每个数组的值表示以这个值为根的集合中元素的个数，然后将元素个数少的集合合并至元素个数多的集合上
改进2：设置一个数组rank，代表两个元素所在树的高度值，根据两个元素所在树的rank来判断合并方向。将rank低的集合合并到rank高的集合上。
改进3：对查找函数进行改进，使用路径压缩的方法，将该元素所在树的高度进行压缩
改进4：使用递归的方法实现路径压缩，将非根节点指向各自的根节点

AVL平衡二分搜索树：
一种自平衡二分搜索树
对于任意一个节点，左子树和右子树的高度差不能超过1
高度和节点数量的关系O(logn)

在各个节点标注其高度
计算平衡因子： 左右子树的高度差   

什么时候去维护平衡： 每次加入节点后，沿着节点向上维护平衡性
旋转细节：对不平衡节点进行左旋转时，对该节点右孩子进行操作，操作，将不平衡节点插入其右孩子的左节点中，原理啊右孩子的左节点插入不平衡节点的右节点中，形成右孩子。

对不平衡节点右旋转时，对该节点的左孩子进行操作，让不平衡节点成为其左孩子的右子树，然后不平衡节点的左子树为原来左孩子节点的右子树

插入的元素在不平衡节点的左侧的左侧

左子树比右子树高度高 -------> 进行右旋转

插入的元素在不平衡节点的右侧的右侧 ---------> 左旋转

LL：新插入的节点在不平衡节点的左孩子的左孩子端   -- > 左旋转
RR：新插入的节点在不平衡节点的右侧的右侧 -- > 右旋转
LR：新插入的节点在不平衡节点的左侧的右侧 -- > 先对不平衡节点的左孩子进行左旋转，形成LL
RL： ..................................................右侧的左侧 -- > 先对不平衡节点的右孩子进行右旋转，形成RR
对哪个节点进行旋转，实际是对该节点的孩子节点进行操作，左旋转对右孩子操作，右旋转对左孩子操作
                  

红黑树：平衡二分搜索树
红黑树与2-3树等价
-----------2-3树------------
满足二分搜索树的性质
节点可以存放一个元素或者两个元素
节点有一个元素，两个孩子，为2节点
节点有两个元素，三个孩子，为3节点
是一个绝对平衡的树（对于任意一个节点，左右子树高度相同）

添加一个节点不会添加到一个空节点的位置，如果是一个叶子节点，会将添加的元素与已经存在的叶子节点进行融合

--------红黑树-------------

2-3树中的三节点，对应到红黑树中，红的为左边的点，黑的为右边的点，这两个点在同一个节点上，但画的时候是按照二分搜索树的方法进行（黑为父节点，红为子节点 ）。这两个节点的连接信息放在红色的节点中。

 所有红色节点都是左倾的，在2-3树中，每一个3节点都会产生一个红节点

红黑树中的五个性质：

```cc
1.每个节点或者是红的，或者是黑的
2.根节点是黑的
3.每个叶子节点（包括最后的空节点）是黑色的
4.如果一个节点是红的，那么他的孩子节点都是黑的
5.从任意一个节点到叶子节点，经过的黑色节点是一样的
```

保持“黑平衡”二叉树，红黑树不是平衡二叉树，最大高度2logn
时间复杂度O(logn)
默认每次添加的节点为红色节点
如果插入的节点为右孩子，需要做一次左旋转，通过左旋转使节点变为3节点

红黑树性能总结、；
对于完全的随机数据，普通的二分搜索树很好用

但在极端的情况下会退化为一个链表

对于查询较多的情况，AVL树很好用

红黑树牺牲了平衡性

但统计性能更优（综合增删改查所有操作）



### 哈希表

每一个字符都和一个索引相对应

哈希函数的设计：

整型：

小范围正整数直接用

小范围负数：进行偏移

大整数：取模

摸一个素数，解决分布不均

浮点型：将浮点数占用的空间转化为整型处理

字符串：转化为整型处理

java中的hashcode

哈希冲突的处理：Seperate chaining

其他方法，开放地址法，只要扩容的量是合适的，则时间复杂度为O(1)













